<MudPaper Class="pa-4 mt-4">
    <MudStack Spacing="4">
        <MudText Typo="Typo.h6">@Template.Title</MudText>
        <MudText Typo="Typo.body2">@Event.Title on @Event.Date.ToString("dddd, MMMM dd, yyyy")</MudText>
        @if (!string.IsNullOrWhiteSpace(Template.Description))
        {
            <MudText Typo="Typo.body1">@Template.Description</MudText>
        }
    </MudStack>
</MudPaper>

@if (Letter.State == LetterState.Submitted)
{
    <MudAlert Severity="Severity.Info" Class="pa-4 mt-4">
        This letter has been submitted and is waiting for admin approval. You can no longer make changes.
    </MudAlert>
}
else if (Letter.State == LetterState.Approved)
{
    <MudAlert Severity="Severity.Info" Class="pa-4 mt-4">
        This letter has been approved! You can no longer make changes.
    </MudAlert>
}

@foreach (var field in Template.Fields)
{
    if (!field.ShowField(Letter.Fields)) continue;
    <MudPaper Class="pa-4 mt-4">
        <MudStack Spacing="0">
            <MudText Typo="@(field.Type == LetterFieldType.Header ? Typo.h6 : Typo.body1)">@field.Title</MudText>
            <MudText Typo="Typo.body2">@field.Description</MudText>

            @switch (field.Type)
            {
                case LetterFieldType.Rating:
                    <MudRating T="int" ReadOnly="ReadOnly" MaxValue="10" SelectedValue="@(GetField<int>(field.Name))" SelectedValueChanged="value => SetInt(field.Name, value)"/>
                    break;
                case LetterFieldType.Text:
                    <MudTextField T="string?" ReadOnly="ReadOnly" Variant="Variant.Outlined" Value="@(GetField<string?>(field.Name))" ValueChanged="value => SetString(field.Name, value)"/>
                    break;
                case LetterFieldType.TextBlock:
                    <MudTextField T="string?" ReadOnly="ReadOnly" Variant="Variant.Outlined" Lines="4" Value="@(GetField<string?>(field.Name))" ValueChanged="value => SetString(field.Name, value)"/>
                    break;
                case LetterFieldType.Selection:
                    <MudSelectExtended T="string?" ReadOnly="ReadOnly" Variant="Variant.Outlined" ItemCollection="field.Options" Value="@(GetField<string>(field.Name))" ValueChanged="value => SetString(field.Name, value)"/>
                    break;
                case LetterFieldType.MultipleSelection:
                    @if (ReadOnly)
                    {
                        <MudChipSet MultiSelection ReadOnly>
                            @foreach (var value in GetField<string[]>(field.Name) ?? Array.Empty<string>())
                            {
                                <MudChip>@value</MudChip>
                            }
                        </MudChipSet>
                    }
                    else
                    {
                        <MudListExtended Dense T="string" Disabled="ReadOnly" MultiSelection ItemCollection="field.Options" SelectedValues="@(GetField<string[]>(field.Name))" SelectedValuesChanged="value => SetStrings(field.Name, value.ToArray())"/>
                    }
                    break;
                case LetterFieldType.YesNo:
                    <MudSwitch T="bool" ReadOnly="ReadOnly" Checked="@(GetField<bool>(field.Name))" CheckedChanged="value => SetBool(field.Name, value)" Color="Color.Success" UnCheckedColor="Color.Error"/>
                    break;
                case LetterFieldType.Removed:
                default:
                    break;
            }
        </MudStack>
    </MudPaper>
}

@code {

    [Parameter]
    public bool ReadOnly { get; set; }

    [Parameter]
    public Event Event { get; set; } = default!;

    [Parameter]
    public Letter Letter { get; set; } = default!;

    [Parameter]
    public LetterTemplate Template { get; set; } = default!;


    private T? GetField<T>(string fieldName)
    {
        try
        {
            if (!Letter.Fields.ContainsKey(fieldName))
                return default;

            if (typeof(T) == typeof(string[]))
            {
                return (T)(object)Letter.Fields[fieldName].Split(',');
            }

            return (T)Convert.ChangeType(Letter.Fields[fieldName], typeof(T));
        }
        catch
        {
            return default;
        }
    }

    private void SetString(string fieldName, string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            Letter.Fields.Remove(fieldName);
        else
            Letter.Fields[fieldName] = value.Trim();
    }

    private void SetInt(string fieldName, int? value)
    {
        if (!value.HasValue)
            Letter.Fields.Remove(fieldName);
        else
            Letter.Fields[fieldName] = value.Value.ToString();
    }

    private void SetBool(string fieldName, bool? value)
    {
        if (!value.HasValue)
            Letter.Fields.Remove(fieldName);
        else
            Letter.Fields[fieldName] = value.Value.ToString();
    }

    private void SetStrings(string fieldName, string[]? values)
    {
        if (values == null || values.Length == 0)
            Letter.Fields.Remove(fieldName);
        else
            Letter.Fields[fieldName] = string.Join(",", values);
    }

}
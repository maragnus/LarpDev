@using MongoDB.Driver.Linq
@inject LandingService LandingService
@inject IDialogService DialogService

<MudStack Row AlignItems="AlignItems.Center">
    <MudSelectExtended
        T="AccountName" ItemCollection="_accountNames" Clearable @ref="_addPlayerComponent"
        ValueChanged="AddAccountChanged" Disabled="_isSaving"
        Placeholder="Add Attendee" Variant="Variant.Outlined" ToStringFunc="@(accountName => accountName.Name ?? "No Name Set")"
        SearchBox="true" SearchBoxAutoFocus SearchFunc="SearchFunc">
        <ItemTemplate>
            <MudStack Spacing="0">
                <MudText Typo="Typo.body1">@context.Value.Name</MudText>
                <MudText Typo="Typo.body2"> @string.Join(", ", context.Value.Emails.Select(x => x.Email))</MudText>
            </MudStack>
        </ItemTemplate>
    </MudSelectExtended>
    <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Save" Color="Color.Success" Disabled="@(!_saveAllNeeded || _isSaving)" OnClick="SaveAll">Save All Changes</MudButton>
</MudStack>

<MudDataGrid T="Attendance" Items="_attendances" ReadOnly="false" Hover EditMode="DataGridEditMode.Cell" Bordered Dense CommittedItemChanges="AttendanceUpdated" Loading="_isSaving">
    <Columns>
        <PropertyColumn Property="x => x.Name" IsEditable="false"/>
        <PropertyColumn Property="x => x.Attended" IsEditable="true">
            <EditTemplate>
                <MudSwitch Checked="@context.Item.Attended" Color="Color.Success" UnCheckedColor="Color.Error" CheckedChanged="(bool value) => { context.Item.Attended = value; context.Item.Changed = true; }"/>
            </EditTemplate>
        </PropertyColumn>
        <PropertyColumn Property="x => x.Moonstone" IsEditable="true"/>
        <TemplateColumn CellClass="d-flex justify-end" Sortable="false" IsEditable="false">
            <CellTemplate>
                @foreach (Letter letter in context.Item.Letters)
                {
                    var style = LetterTooltip[letter.State];
                    var icon = LetterIcon[letter.Name];
                    <MudTooltip Text="@style.Tooltip">
                        <MudIconButton Size="Size.Medium" Color="style.Color" Icon="@icon" OnClick="async () => await ShowLetter(letter)"/>
                    </MudTooltip>
                }
                <MudIconButton Size="Size.Medium" Color="Color.Primary" Icon="@Icons.Material.Filled.Save" Disabled="@(!context.Item.Changed)" OnClick="async () => await AttendanceUpdate(context.Item)"/>
            </CellTemplate>
        </TemplateColumn>
    </Columns>
</MudDataGrid>

@code {

    [Parameter]
    public EventsAndLetters EventsAndLetters { get; set; } = default!;

    private class Attendance
    {
        public string AccountId { get; set; } = default!;
        public string Name { get; set; } = default!;
        public bool Attended { get; set; }
        public int? Moonstone { get; set; }
        public string[] CharacterIds { get; set; } = Array.Empty<string>();
        public bool Changed { get; set; }
        public Letter[] Letters { get; set; } = Array.Empty<Letter>();
    }
    
    static readonly Dictionary<LetterState, (string Tooltip, Color Color)> LetterTooltip = new()
    {
        { LetterState.NotStarted, ("You have not started the letter for this event", Color.Warning) },
        { LetterState.Draft, ("You have not submitted this letter yet", Color.Warning) },
        { LetterState.Submitted, ("Your event letter has been submitted and is waiting for approval", Color.Tertiary) },
        { LetterState.Approved, ("Your event letter has been approved", Color.Success) },
    };
    
    static readonly Dictionary<string, string> LetterIcon = new()
    {
        { "PreEvent", Icons.Material.Filled.Rsvp },
        { "PostEvent", Icons.Material.Filled.Email },
    };

    bool _isLoading = true;
    private List<EventComponent> _components = new();
    private readonly List<Attendance> _attendances = new();
    private MudSelectExtended<AccountName>? _addPlayerComponent;
    private bool _saveAllNeeded;
    private bool _isSaving = true;
    private AccountName[] _accountNames = Array.Empty<AccountName>();
    private Event _event = default!;
    private string? _lastEventId;
    private Dictionary<string, LetterTemplate> _templates = default!;

    protected override async Task OnParametersSetAsync()
    {
        _event = EventsAndLetters.Events.Values.First();
        if (_lastEventId == _event.EventId) return;
        _lastEventId = _event.EventId;

        var names = EventsAndLetters.Accounts;
        _accountNames = names.Values.ToArray();
        _templates = EventsAndLetters.LetterTemplates;
        
        _isLoading = true;
        var letterLookup = EventsAndLetters.Letters.Values
            .GroupBy(x => x.AccountId)
            .ToDictionary(x => x.Key, x => x.ToArray());
        var attendances = await LandingService.Admin.GetEventAttendances(_event.EventId);
        _attendances.AddRange(attendances.Select(attendance =>
        {
            return new Attendance()
            {
                AccountId = attendance.AccountId,
                Name = names.GetValueOrDefault(attendance.AccountId)?.Name ?? "No Name Set",
                Attended = true,
                Moonstone = attendance.MwFifth?.Moonstone ?? 0,
                CharacterIds = attendance.MwFifth?.CharacterIds ?? Array.Empty<string>(),
                Letters = letterLookup.Remove(attendance.AccountId, out var letters) ? letters : Array.Empty<Letter>()
            };
        }));
        _attendances.AddRange(letterLookup.Select(letter => new Attendance()
        {
            AccountId = letter.Key,
            Name = names.GetValueOrDefault(letter.Key)?.Name ?? "No Name Set",
            Attended = false,
            Letters = letter.Value
        }));

        _isLoading = false;
        _isSaving = false;
    }

    private bool SearchFunc(AccountName accountName, string query) =>
        accountName.Name?.Contains(query, StringComparison.InvariantCultureIgnoreCase) == true
        || accountName.Emails.Any(email => email.Email.Contains(query, StringComparison.InvariantCultureIgnoreCase));

    private async Task SaveAll()
    {
        _isSaving = true;
        StateHasChanged();
        try
        {
            await Parallel.ForEachAsync(
                _attendances.Where(x => x.Changed),
                new ParallelOptions { MaxDegreeOfParallelism = 4 },
                async (attendance, token) => { await AttendanceUpdate(attendance); });
            UpdateSaveAllNeeded();
        }
        finally
        {
            _isSaving = false;
        }
    }

    private void UpdateSaveAllNeeded()
    {
        _saveAllNeeded = _attendances.Any(x => x.Changed);
    }

    private async Task SaveAttendance(Attendance item)
    {
        await LandingService.Admin.SetEventAttendance(_event.EventId, item.AccountId, item.Attended, item.Moonstone, Array.Empty<string>());
        item.Changed = false;
    }


    private async Task AttendanceUpdate(Attendance item)
    {
        await SaveAttendance(item);
        UpdateSaveAllNeeded();
    }

    private async Task AddAccountChanged(AccountName player)
    {
        if ((AccountName?)player == null) return;

        if (_attendances.Any(x => x.AccountId == player.AccountId))
        {
            await DialogService.ShowMessageBox("Add Player", "This player is already added to the attendance list.");
            await _addPlayerComponent!.Clear();
            return;
        }

        var item = new Attendance
        {
            Attended = true,
            Moonstone = 0,
            Name = player.Name ?? "No Name Set",
            AccountId = player.AccountId,
            Changed = false
        };
        _attendances.Add(item);

        await LandingService.Admin.SetEventAttendance(_event.EventId, item.AccountId, item.Attended, item.Moonstone, Array.Empty<string>());

        await _addPlayerComponent!.Clear();
        StateHasChanged();
    }

    private void AttendanceUpdated(Attendance obj)
    {
        obj.Changed = true;
        _saveAllNeeded = true;
    }

    private async Task ShowLetter(Letter? letter)
    {
        if (letter == null)
            return;

        var options = new DialogOptions()
        {
            CloseOnEscapeKey = true, CloseButton = true, Position = DialogPosition.TopCenter
        };
        var parameters = new DialogParameters()
        {
            { nameof(LetterDialog.Template), _templates[letter.TemplateId] },
            { nameof(LetterDialog.Letter), letter },
            { nameof(LetterDialog.Event), _event },
            { nameof(LetterDialog.ReadOnly), true },
            { nameof(LetterDialog.Admin), true }
        };
        await DialogService.ShowAsync<LetterDialog>(EventsAndLetters.Accounts[letter.AccountId].Name, parameters, options);
    }

}